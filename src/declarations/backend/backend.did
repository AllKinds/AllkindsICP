type UserMatch = 
 record {
   answered: vec record {
                   Question__1;
                   AnswerDiff;
                 };
   cohesion: nat8;
   uncommon: vec Question__1;
   user: UserInfo;
 };
type UserInfo = 
 record {
   about: opt text;
   age: opt nat8;
   gender: opt Gender;
   picture: opt blob;
   socials: vec Social;
   username: text;
 };
type User = 
 record {
   about: record {
            opt text;
            IsPublic;
          };
   age: record {
          opt nat8;
          IsPublic;
        };
   created: Time;
   gender: record {
             opt Gender;
             IsPublic;
           };
   picture: record {
              opt blob;
              IsPublic;
            };
   points: nat;
   socials: vec record {
                  Social;
                  IsPublic;
                };
   username: text;
 };
type Time__1 = int;
type Time = int;
type StableQuestion = 
 record {
   color: text;
   created: Time__1;
   creator: principal;
   id: QuestionID__1;
   points: int;
   question: text;
 };
type SocialNetwork = 
 variant {
   distrikt;
   dscvr;
   email;
   mastodon;
   phone;
   twitter;
 };
type Social = 
 record {
   handle: text;
   network: SocialNetwork;
 };
type Skip = 
 record {
   question: nat;
   reason: variant {
             flag;
             skip;
           };
 };
type ResultUserMatch = 
 variant {
   err: Error;
   ok: UserMatch;
 };
type ResultUser = 
 variant {
   err: Error;
   ok: User;
 };
type ResultSkip = 
 variant {
   err: Error;
   ok: Skip;
 };
type ResultQuestion = 
 variant {
   err: Error;
   ok: Question;
 };
type ResultFriends = 
 variant {
   err: Error;
   ok: vec Friend;
 };
type ResultAnswer = 
 variant {
   err: Error;
   ok: Answer;
 };
type Result = 
 variant {
   err: Error;
   ok;
 };
type Question__1 = 
 record {
   color: text;
   created: Time__1;
   creator: opt text;
   id: QuestionID__1;
   points: int;
   question: text;
 };
type QuestionID__1 = nat;
type QuestionID = nat;
type Question = 
 record {
   color: text;
   created: Time__1;
   creator: opt text;
   id: QuestionID__1;
   points: int;
   question: text;
 };
type IsPublic = bool;
type Gender = 
 variant {
   female;
   male;
   other;
   queer;
 };
type FriendStatus = 
 variant {
   connected;
   rejectionReceived;
   rejectionSend;
   requestIgnored;
   requestReceived;
   requestSend;
 };
type Friend = 
 record {
   UserMatch;
   FriendStatus;
 };
type Error = 
 variant {
   alreadyRegistered;
   friendAlreadyConnected;
   friendRequestAlreadySend;
   insufficientFunds;
   invalidColor;
   nameNotAvailable;
   notEnoughAnswers;
   notLoggedIn;
   notRegistered;
   tooLong;
   tooShort;
   userNotFound;
   validationError;
 };
type AnswerDiff = 
 record {
   question: nat;
   sameAnswer: bool;
   weight: nat;
 };
type Answer = 
 record {
   answer: bool;
   created: Time__1;
   question: nat;
   weight: nat;
 };
service : {
  airdrop: (text, int) -> (Result);
  answerFriendRequest: (text, bool) -> (Result);
  backupAnswers: (nat, nat) -> (vec StableQuestion) query;
  backupConnections: (nat, nat) ->
   (vec record {
          principal;
          principal;
          FriendStatus;
        }) query;
  backupQuestions: (nat, nat) -> (vec StableQuestion) query;
  backupUsers: (nat, nat) -> (vec record {
                                    principal;
                                    User;
                                  }) query;
  createQuestion: (text, text) -> (ResultQuestion);
  createUser: (text, text) -> (ResultUser);
  findMatch: (nat8, nat8, opt Gender, nat8) -> (ResultUserMatch);
  getAnsweredQuestions: (nat) -> (vec record {
                                        Question;
                                        Answer;
                                      }) query;
  getFriends: () -> (ResultFriends) query;
  getOwnQuestions: (nat) -> (vec Question) query;
  getUnansweredQuestions: (nat) -> (vec Question) query;
  getUser: () -> (ResultUser) query;
  selfDestruct: (text) -> () oneway;
  sendFriendRequest: (text) -> (Result);
  submitAnswer: (QuestionID, bool, nat) -> (ResultAnswer);
  submitSkip: (nat) -> (ResultSkip);
  updateProfile: (User) -> (ResultUser);
  whoami: () -> (principal) query;
}
