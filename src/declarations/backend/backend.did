type UserStats = 
 record {
   answered: nat;
   asked: nat;
   boosts: nat;
   points: nat;
 };
type UserMatch = 
 record {
   answered: vec record {
                   Question__1;
                   AnswerDiff;
                 };
   cohesion: nat8;
   uncommon: vec Question__1;
   user: UserInfo;
 };
type UserInfo = 
 record {
   about: text;
   contact: text;
   displayName: text;
   picture: opt blob;
   username: text;
 };
type User = 
 record {
   about: text;
   contact: text;
   created: Time;
   displayName: text;
   picture: opt blob;
   stats: UserStats;
   username: text;
 };
type Time__1 = int;
type Time = int;
type StableQuestion = 
 record {
   color: text;
   created: Time__1;
   creator: principal;
   id: QuestionID__1;
   points: int;
   question: text;
 };
type Skip = 
 record {
   question: nat;
   reason: variant {
             flag;
             skip;
           };
 };
type ResultUserMatches = 
 variant {
   err: Error;
   ok: vec UserMatch;
 };
type ResultUser = 
 variant {
   err: Error;
   ok: User;
 };
type ResultSkip = 
 variant {
   err: Error;
   ok: Skip;
 };
type ResultQuestion = 
 variant {
   err: Error;
   ok: Question;
 };
type ResultFriends = 
 variant {
   err: Error;
   ok: vec Friend;
 };
type ResultAnswer = 
 variant {
   err: Error;
   ok: Answer;
 };
type Result = 
 variant {
   err: Error;
   ok;
 };
type Question__1 = 
 record {
   color: text;
   created: Time__1;
   creator: opt text;
   id: QuestionID__1;
   points: int;
   question: text;
 };
type QuestionID__1 = nat;
type QuestionID = nat;
type Question = 
 record {
   color: text;
   created: Time__1;
   creator: opt text;
   id: QuestionID__1;
   points: int;
   question: text;
 };
type FriendStatus = 
 variant {
   connected;
   rejectionReceived;
   rejectionSend;
   requestReceived;
   requestSend;
 };
type Friend = 
 record {
   UserMatch;
   FriendStatus;
 };
type Error = 
 variant {
   alreadyRegistered;
   friendAlreadyConnected;
   friendRequestAlreadySend;
   insufficientFunds;
   invalidColor;
   nameNotAvailable;
   notEnoughAnswers;
   notInTeam;
   notLoggedIn;
   notRegistered;
   tooLong;
   tooShort;
   userNotFound;
   validationError;
 };
type AnswerDiff = 
 record {
   question: nat;
   sameAnswer: bool;
   weight: nat;
 };
type Answer = 
 record {
   answer: bool;
   created: Time__1;
   question: nat;
   weight: nat;
 };
service : {
  airdrop: (text, int) -> (Result);
  answerFriendRequest: (text, text, bool) -> (Result);
  backupAnswers: (text, nat, nat) -> (vec StableQuestion) query;
  backupConnections: (text, nat, nat) ->
   (vec record {
          principal;
          principal;
          FriendStatus;
        }) query;
  backupQuestions: (text, nat, nat) -> (vec StableQuestion) query;
  backupUsers: (nat, nat) -> (vec record {
                                    principal;
                                    User;
                                  }) query;
  createQuestion: (text, text, text) -> (ResultQuestion);
  createTestData: (text, nat, nat) -> (nat);
  createUser: (text, text) -> (ResultUser);
  getAnsweredQuestions: (text, nat) -> (vec record {
                                              Question;
                                              Answer;
                                            }) query;
  getFriends: (text) -> (ResultFriends) query;
  getMatches: (text) -> (ResultUserMatches) query;
  getOwnQuestions: (text, nat) -> (vec Question) query;
  getUnansweredQuestions: (text, nat) -> (vec Question) query;
  getUser: () -> (ResultUser) query;
  selfDestruct: (text) -> () oneway;
  sendFriendRequest: (text, text) -> (Result);
  submitAnswer: (text, QuestionID, bool, nat) -> (ResultAnswer);
  submitSkip: (text, nat) -> (ResultSkip);
  updateProfile: (User) -> (ResultUser);
  whoami: () -> (principal) query;
}
